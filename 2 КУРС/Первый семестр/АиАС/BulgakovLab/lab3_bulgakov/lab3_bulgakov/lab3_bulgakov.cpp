#include "pch.h"
#include <iostream>
#include <fstream>
#include <queue>
#define k 8

using namespace std;

// Описание структуры (Шахматная клетка)
struct cell
{
	int x; // координата x для клетки
	int y; // координата y для клетки

	// конструктор с параметрами
	cell(int i, int j) 
	{
		x = i;
		y = j;
	}

	/* конструктор по умолчанию 
	(если мы не задаем каких то параметров или условий, 
	то новые переменные будут инициализироваться сами 
	при помощи конструктора по умолчанию)
	значение по умолчанию будет -1 и для x и для y
	*/
	cell() 
	{
		x = -1;
		y = -1;
	}
};


int n; // по условию доска размера n на n
char** ChessBoard; // глобальная переменная для хранения шахматной доски
cell* empty_cell; // переменная, которая будет хранить значение пустой клетки (-1, -1)
cell** Parents; // массив для хранения предков клетки(-ок)

// Функция инициализации некоторых переменных и выделения памяти
void Initialization()
{
	/* 
		используем конструктор по умолчанию для инициализации переменной empty_cell
		и двумерного массива Parents
	*/
	empty_cell = new cell;
	Parents = new cell*[n];
	for (int i = 0; i < n; i++)
	{
		Parents[i] = new cell[n];
	}
	// Выделяем память для переменной ChessBoard (исходная шахматная доска)
	ChessBoard = new char*[n];
	for (int i = 0; i < n; i++)
	{
		ChessBoard[i] = new char[n];
	}
}

// Функция чтения данных из файла
void Read()
{
	ifstream in_file("in.txt");
	in_file >> n; // считываем размер доски (n на n) 
	Initialization(); // вызываем функцию инициализации и выделения памяти
	// Затем считываем исходную шахматную доску
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			in_file >> ChessBoard[i][j];
		}
	}
	in_file.close();
}

// Функция поиска стартовой и финишной клеток
void SearchStartAndFinishCells(cell* &start, cell* &finish)
{
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			/* 
				проходим по всему массиву хранящему исходную шахматную доску
				пока не встретим символ @
			*/
			if (ChessBoard[i][j] == '@') 
			{
				if (start->x == -1) 
				{
					/*
						если стартовая вершина имееет значение по умолчанию
						то текущая клетка будет стартовой
					*/
					start = new cell(i, j);
				}
				else
				{
					/*
						если стартовая клетка уже была инициализированна
						(то есть она имеет значение отличное от значения по умолчанию)
						то текущая клетка будет финишной
					*/
					finish = new cell(i, j);
				}
			}
		}
	}
}

// Функция проверки не выйдет ли наш конь за границу шахматной доски
bool NoRoad(cell* g)
{
	return (g->x < 0 || g->x >= n || g->y < 0 || g->y >= n);
}

// Функция проверки не является ли клетка вырезанной
bool CanGo(cell* g)
{
	return ChessBoard[g->x][g->y] != '#';
}

// Функции проверки равенства переменных типа cell*
bool Equal(cell a, cell* b)
{
	return (a.x == b->x) && (a.y == b->y);
}

// Функции проверки равенства переменных типа cell* и cell
bool Equal(cell* a, cell* b)
{
	return (a->x == b->x) && (a->y == b->y);
}

// Функция поиска пути из стартоврй вершины в финишную 
bool SearchRoad(cell* start, cell* finish)
{
	// два массива которые хранят все 8 возможных перемещений слона по доске
	int dx[k] = { 2,2,-2,-2,1,1,-1,-1 }; // отвечает за перемещение по х
	int dy[k] = { 1,-1,1,-1,2,-2,2,-2 }; // отвечает за перемещение по у
	queue<cell*> q; // очередь для обхода в ширину
	q.push(start); // записываем в очередь стартовую клетку (с нее начнется обход)
	// Цикл продолжается пока в очереди есть хотя бы одна клетка (пока очередь не пуста)
	while (!q.empty())
	{
		/*
			первая клетка в очереди будет текущей (current),
			с ней мы будем работать на текущем шаге
		*/
		cell* curent = q.front();
		/*
			теперь мы перебираем все возможные клетки,
			куда может попасть наш конь из текущей клетки (current)
			(таких всего 8)
		*/
		for (int i = 0; i < k; i++)
		{
			/*
				 Используем конструктор с параметрами для инициализации клетки
				 в которую мы можем попасть из текущей (next)
				 координаты клетки будут равны координатам текущей клетки (current) +
				 i-тое перемещение (одно из 8 возможных перемещений) коня по доске
				 (перемещения по х и по y храняться соответственно в массивах dx и dy)
			*/
			cell* next = new cell(curent->x + dx[i], curent->y + dy[i]);

			// проверяем не выйдут ли координаты нашей следующей клетки (next) за границы доски
			if (!NoRoad(next))
			{
				// проверяем не является ли наша клетка вырезанной
				/*
					 проверяем не были ли мы уже в этой клетке
					 если элемент массива предков (Parents) с индексами соответствующими
					 координатам клетки next равен пустой клетке
					 значит в этой клетке (next) мы еще не были
					 и следовательно мы входим в тело данного if
				*/
				if (CanGo(next) && Equal(Parents[next->x][next->y], empty_cell))
				{
					/*
						значение элемента массива предков (Parents) с индексами соответствующими
						координатам клетки next будут равно клетке current,
						так как current являктся предком next
						(из current мы попали в клетку next за один ход коня)
					*/
					Parents[next->x][next->y].x = curent->x;
					Parents[next->x][next->y].y = curent->y;

					/*
						 если клетка next равна клетке finish
						 значит мы начли путь из стартовой клетки в финишную
						 и мы можем выходить из функции
					*/
					if (Equal(next, finish))
					{
						return true;
					}
					q.push(next); // закидываем клетку next в очередь
				}
			}
		}
		q.pop(); // выкидываем из очереди клетку которую мы уже обработали на текущем шаге
	}
	return false; // если мы оказались здесь, значит мы обошли все возможные пути коня, но не нашли путь в finish
}

int main()
{
	setlocale(0, "");
	Read();
	// инициализируем переменные start и finish (стартовая и финишная клетки) с помощью конструктора по умолчанию
	cell* start = new cell;
	cell* finish = new cell;
	SearchStartAndFinishCells(start, finish); // ищем стартовые и финишные клетки на доске
	if (!SearchRoad(start, finish)) // проверяем возможно ли попасть из клетки start в клетку finish
	{
		// если нет, то выводим соответствующий ответ
		cout << "Imposible.\n\n";
	}
	else
	{
		// в противном случае путь в клетку finish найден

		/*
			теперь мы будем идти по массиву предков пока не дойдем из финишной вершины в стартовую,
			попутно меняем все клетки через которые проходим на символ @
		*/
		while (!Equal(start, finish))
		{
			ChessBoard[finish->x][finish->y] = '@';
			finish = new cell(Parents[finish->x][finish->y].x, Parents[finish->x][finish->y].y);
		}

		// выводим получившуюся шахматную доску
		for (int i = 0; i < n; i++)
		{
			for (int j = 0; j < n; j++)
			{
				cout << ChessBoard[i][j];
			}
			cout << endl;
		}
	}
	return 0;
}
